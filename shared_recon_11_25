Add-Type -AssemblyName System.Windows.Forms

# --- Folder selection ---
$dlg = New-Object System.Windows.Forms.FolderBrowserDialog
$dlg.Description = "Select the root directory to scan"
if ($dlg.ShowDialog() -ne "OK") { exit }
$root = $dlg.SelectedPath

$outputFile = "C:\path\to\secret_scan_results.txt"
"" | Out-File $outputFile

# --- Patterns to detect secrets ---
$patterns = @(
    "password","passwd","credential","creds?",
    "apikey","api key","token","secret","auth","bearer",
    "jwt","refresh_token","sessionid","access_token",
    "AKIA[0-9A-Z]{16}",
    "ASIA[0-9A-Z]{16}",
    "AIza[0-9A-Za-z\-_]{35}",
    "ya29.[0-9A-Za-z\-_]+",
    "sk_live_[0-9A-Za-z]+",
    "sk_test_[0-9A-Za-z]+",
    "-----BEGIN PRIVATE KEY-----",
    "-----BEGIN RSA PRIVATE KEY-----",
    "-----BEGIN OPENSSH PRIVATE KEY-----",
    "-----BEGIN EC PRIVATE KEY-----",
    "-----BEGIN DSA PRIVATE KEY-----",
    "-----BEGIN CERTIFICATE-----",
    "ssh-rsa","ssh-ed25519",
    "connectionstring","uid=","pwd=","db_password","db_user"
)

# --- Extract text from docx/xlsx/pptx ---
function Expand-OfficeZip($Path) {
    $tmp = Join-Path $env:TEMP ([System.IO.Path]::GetRandomFileName())
    try {
        Expand-Archive -LiteralPath $Path -DestinationPath $tmp -ErrorAction Stop
        $text = Get-ChildItem $tmp -Recurse -File |
            Where-Object {$_.Extension -match "xml|txt|json"} |
            ForEach-Object { Get-Content $_.FullName -Raw -ErrorAction SilentlyContinue }
    } catch {
        $text = $null
    } finally {
        Remove-Item $tmp -Recurse -Force -ErrorAction SilentlyContinue
    }
    return $text
}

# --- Safe text extractor ---
function Get-FileText($fileObj) {

    # Skip binary Excel formats
    if ($fileObj.Extension.ToLower() -eq ".xls") {
        return $null
    }

    switch ($fileObj.Extension.ToLower()) {
        ".txt" { return Get-Content $fileObj.FullName -Raw -ErrorAction SilentlyContinue }
        ".json" { return Get-Content $fileObj.FullName -Raw }
        ".xml" { return Get-Content $fileObj.FullName -Raw }
        ".html" { return Get-Content $fileObj.FullName -Raw }
        ".md" { return Get-Content $fileObj.FullName -Raw }
        ".yaml" { return Get-Content $fileObj.FullName -Raw }
        ".yml" { return Get-Content $fileObj.FullName -Raw }
        ".ini" { return Get-Content $fileObj.FullName -Raw }
        ".csv" { return Get-Content $fileObj.FullName -Raw }

        ".docx" { return Expand-OfficeZip $fileObj.FullName }
        ".xlsx" { return Expand-OfficeZip $fileObj.FullName }
        ".pptx" { return Expand-OfficeZip $fileObj.FullName }

        default { return $null }
    }
}

# --- Recursive scan with error skipping ---
Get-ChildItem -Path $root -Recurse -File -Force -ErrorAction SilentlyContinue |
ForEach-Object {

    $file = $_
    Write-Host "Scanning: $($file.FullName)"

    # Start timed read (10 sec)
    $job = Start-Job -ScriptBlock {
        param($f)
        try { Get-FileText $f } catch { $null }
    } -ArgumentList $file

    Wait-Job $job -Timeout 10 | Out-Null
    if (-not $job.HasExited) {
        Write-Host "Timeout: Skipping $($file.FullName)" -ForegroundColor Cyan
        Stop-Job $job -Force | Out-Null
        Remove-Job $job | Out-Null
        return
    }

    $content = Receive-Job $job -ErrorAction SilentlyContinue
    Remove-Job $job

    if (-not $content) { return }

    foreach ($pattern in $patterns) {
        if ($content -match $pattern) {
            $msg = "MATCH: '$pattern' in $($file.FullName)"
            $msg | Tee-Object -FilePath $outputFile -Append
            Write-Host $msg -ForegroundColor Yellow
        }
    }
}

Write-Host "DONE. Results saved to $outputFile"
